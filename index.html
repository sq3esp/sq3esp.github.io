<html>
<head>
<meta charset="utf-8">
<title> BAZA ASK </title>

<style>
html{
    background: #ccffff;
}
.correct{
    background: #66ff99;
} 
ol{ 
}
</style>
</head>
<body>
<p>1.	Czy $sp w MIPS to:
<ul><p>	(a) stop pointer - wskaźnik zatrzymania programu
<p>	(b) super position - tryb pracy procesora, pozwalający na zwiększenie jego szybkości
<p><a class="correct">	(c) stack pointer - rejestr ze wskaźnikiem początku stosu
</a><p>	(d) stop position - warunek stopu aplikacji
<p></ul><p><p>2.	Ile argumentów ma komenda sub?
<ul><p>	(a) cztery (trzy rejestry wejściowe do odejmowania, jeden rejestr docelowy do wyniku)
<p>	(b) co najmniej dwa (co najmniej jeden wejściowy, jeden rejestr docelowy do wyniku)
<p><a class="correct">	(c) trzy (dwa rejestry wejściowe do odejmowania, jeden rejestr docelowy do wyniku)
</a><p>	(d) pięć (cztery rejestry wejściowe do odejmowania, jeden rejestr docelowy do wyniku)
<p></ul><p><p>3.	Do jakiej klasy wedle taksonomii Flynna można zaliczyć GPU?
<ul><p>	(a) MISD
<p>	(b) SISD
<p><a class="correct">	(c) SIMD
</a><p>	(d) MIMD
<p></ul><p><p>4.	Architektura RISC w porównaniu z architekturą CISC (np. MIPS vs Intel x86-64):
<ul><p><a class="correct">	(a) jest częściej wykorzystywana w urządzeniach mobilnych (telefony, tablety itp.)
</a><p>	(b) jest starą i już niewykorzystywaną architekturą
<p>	(c) ma więcej bardziej złożonych instrukcji zmiennej długości
<p>	(d) jest mniej bezpieczna przez to jak stworzono ISA
<p></ul><p><p>5.	Instrukcja w architekturze MIPS:
<ul><p>	(a) może mieć zmienną długość
<p><a class="correct">	(b) ma zawsze 32 bity długości
</a><p>	(c) zawsze ma odpowiednik o tej samej nazwie w architekturze CISC
<p>	(d) jest zabezpieczona przed nieuprawnionym wykonaniem przez GU
<p></ul><p><p>6.	Do czego służy instrukcja lw?
<ul><p><a class="correct">	(a) ładuje słowo z pamięci do rejestru
</a><p>	(b) przenosi słowo pomiędzy komórkami pamięci
<p>	(c) przenosi słowo pomiędzy rejestrami
<p>	(d) zapisuje słowo z rejestru do pamięci
<p></ul><p><p>7.	Czym jest pipelining / potokowanie?
<ul><p>	(a) przesyłanie danych pomiędzy rejestrami w celu optymalizacji wydajności
<p>	(b) specjalne wejście procesora dla potoku danych
<p>	(c) zabezpieczenie przed nadpisaniem wrażliwych obszarów pamięci systemu operacyjnego
<p><a class="correct">	(d) wykonywanie kilku instrukcji jednocześnie przez procesor
</a><p></ul><p><p>8.	Instrukcja w architekturze MIPS:
<ul><p><a class="correct">	(a) nie zawsze jest zaimplementowana sprzętowo
</a><p>	(b) nigdy nie pokrywa się z ISA CISC
<p>	(c) jest zmiennej długości od 16 do 64 bitów
<p>	(d) MIPS nie ma instrukcji
<p></ul><p><p>9.	Długość słowa w architekturze MIPS to:
<ul><p><a class="correct">	(a) 32 bity
</a><p>	(b) 64 bity
<p>	(c) 16 bitów
<p>	(d) 8 bitów
<p></ul><p><p>10.	Jaka jest pozytywna cecha architektury Harvard?
<ul><p>	(a) możliwość autodiagnozy uszkodzeń i włączania obwodów zapasowych
<p>	(b) dane duplikowane są w wielu obszarach pamięci, przez co można szybciej je znaleźć
<p>	(c) istnieje wiele szyn danych od procesora do pamięci
<p><a class="correct">	(d) dane i instrukcje zajmują rozłaczne obszary systemu komputerowego - zmniejszone ryzyko wykonania nieuprawnionej intrukcji
</a><p></ul><p><p>11.	W jednej lini asemblera MIPS można:
<ul><p>	(a) napisać więcej niż jedną instrukcję
<p>	(b) podać wprost kod maszynowy instrukcji (ciąg zer i jedynek)
<p><a class="correct">	(c) zadeklarować dane, a później umieścić komentarz
</a><p>	(d) napisać najpierw komentarz, później instrukcję
<p></ul><p><p>12.	Czym są rejestry ogólnego preznaczenia (GPR - general purpose registers)?
<ul><p>	(a) rejestrem dostępnych wejść i wyjść ogólnego przeznaczenia (I/O)
<p>	(b) rejestrem operacji dostępnych w danej architekturze
<p>	(c) wykazem dostępnych źródeł pamięci RAM
<p><a class="correct">	(d) nabliższym procesora miejscem przechowywania danych
</a><p></ul><p><p>13.	Czy możliwe jest zaimplementowanie pętli w asemblerze MIPS?
<ul><p><a class="correct">	(a) tak, kombinacją kilku instrukcji
</a><p>	(b) tak, instrukcją for
<p>	(c) nie ma takiej możliwości, konieczny jest język wysokiego poziomu
<p>	(d) tak, instrukcją while
<p></ul><p><p>14.	Jaka klauzula w asemblerze MIPS rozpoczyna deklarację danych?
<ul><p><a class="correct">	(a) .data
</a><p>	(b) .var
<p>	(c) .declare
<p>	(d) .text
<p></ul><p><p>15.	Jaka klauzula w asemblerze MIPS rozpoczyna kod programu (instrukcji)?
<ul><p>	(a) .data
<p>	(b) .var
<p>	(c) .declare
<p><a class="correct">	(d) .text
</a><p></ul><p><p>16.	Czy dana instrukcja MIPS ma poprawną składnię: lw 4($t1)?
<ul><p>	(a) nie, ponieważ w MIPS nie ma instrukcji lw
<p>	(b) tak
<p>	(c) nie, ponieważ 4 powinno być podzielne bez reszty przez 8 (długość słowa w MIPS wyrażana jest w bajtach)
<p><a class="correct">	(d) nie, ponieważ instrukcji lw jest potrzebny jeszcze jeden argument
</a><p></ul><p><p>17.	Czy dana instrukcja MIPS ma poprawną składnię: lw $t0, 4($t1)?
<ul><p>	(a) nie, ponieważ w MIPS nie ma instrukcji lw
<p><a class="correct">	(b) tak
</a><p>	(c) nie, ponieważ 4 powinno być podzielne bez reszty przez 8 (długość słowa w MIPS wyrażana jest w bajtach)
<p>	(d) nie, ponieważ instrukcji lw jest potrzebny jeszcze jeden argument
<p></ul><p><p>18.	Które dane zostaną utracone po ponownym uruchomieniu komputera?
<ul><p>	(a) na dysku twardym
<p>	(b) na dysku SSD
<p>	(c) w napędzie taśmowym
<p><a class="correct">	(d) w rejestrach
</a><p></ul><p><p>19.	Czym jest rejestr $pc w MIPS?
<ul><p><a class="correct">	(a) jest to rejestr wskazujący gdzie w pamięci procesor będzie szukał następnej instrukcji
</a><p>	(b) jest to rejestr wskazujący na wersję (commit) programu uruchamianego na CPU
<p>	(c) jest to pośredni rejestr wykorzystywany przy przekazywaniu wartości do rejestru
<p>	(d) jest to rejestr pozostawiony ze względów kompatybilnościowych, obecnie nieużywany
<p></ul><p><p>20.	Co znajduje się na szczycie hierarchii pamięci?
<ul><p>	(a) cache procesora
<p>	(b) napęd taśmowy
<p><a class="correct">	(c) rejestry procesora
</a><p>	(d) pamięć RAM
<p></ul><p><p>21.	Jaka wartość znajdzie się w rejestrze $0 po wykonaniu add $0, $1, $2
<ul><p><a class="correct">	(a) zero
</a><p>	(b) nie wiadomo, bo nie znamy wartości w rejestrach $1 i $2
<p>	(c) instrukcja ma nieprawidłową składnię, powinna mieć cztery argumenty
<p>	(d) wartość w rejestrze $0 nie zmieni się, zmieni się wartość w $2 (będzie sumą $0 i $1)
<p></ul><p><p>22.	Która z poniższych architektur zakłada wspólną pamięć dla instrukcji i danych?
<ul><p>	(a) architektura Łukasiewicza
<p>	(b) architektura Stanford
<p><a class="correct">	(c) architektura Princeton (von Neumann)
</a><p>	(d) architektura Harvard
<p></ul><p><p>23.	Czego NIE definiuje ISA (Instruction Set Architecture)?
<ul><p>	(a) zbioru dostępnych rejestrów
<p>	(b) organizacji pamięci
<p>	(c) wyboru instrukcji
<p><a class="correct">	(d) modeli dostępnych procesorów
</a><p></ul><p><p>24.	Instrukcje I-type w MIPS:
<ul><p>	(a) zajmują się obsługą przerwań I/O (interrupts)
<p>	(b) obsługują szybkie indeksowanie (indexing)
<p>	(c) nie występują, są tylko w CISC
<p><a class="correct">	(d) pracują na wartościach (immediate)
</a><p></ul><p><p>25.	Jaki jest rozmiar branch delay slot w MIPS?
<ul><p><a class="correct">	(a) jedna instrukcja
</a><p>	(b) dwie instrukcje
<p>	(c) trzy instrukcje lub więcej
<p>	(d) MIPS nie ma branch delay slot
<p></ul><p><p>26.	Asembler MIPS pozwala na:
<ul><p><a class="correct">	(a) ładowanie słów z pamięci do rejestrów
</a><p>	(b) umieszczenie w jednej instrukcji addi więcej niż jednej wartości immediate
<p>	(c) zmianę kolejności podawania rejestrów źródłowych i docelowych w instrukcji
<p>	(d) ładowanie wielokrotności słów do rejestrów GPR
<p></ul><p><p>27.	Który z tych układów najszybciej będzie wykonywał jedno konkretne zadanie?
<ul><p>	(a) CPU w architekturze RISC
<p>	(b) CPU w architekturze CISC
<p>	(c) FPGA
<p><a class="correct">	(d) ASIC
</a><p></ul><p><p>28.	Długość słowa (word):
<ul><p>	(a) jest pojęciem obecnie niewykorzystywanym
<p>	(b) jest zawsze stała we wszystkich architekturach
<p><a class="correct">	(c) może się różnić w zależności od architektury (ISA)
</a><p>	(d) definiuje się ją na początku programu w asemblerze
<p></ul><p><p>29.	Co cechuje rejestry ogólnego przeznaczenia (GPR)?
<ul><p>	(a) nie można się do nich dostać z poziomu języka asembler
<p>	(b) znajdują się w różnych miejsach systemu komputerowego
<p><a class="correct">	(c) są małych rozmiarów i jest ich mało
</a><p>	(d) z racji rozmiaru są bardzo wolne
<p></ul><p><p>30.	Która rodzina instrukcji NIE istnieje w MIPS?
<ul><p>	(a) J-type (jump)
<p>	(b) R-type (register)
<p><a class="correct">	(c) S-type (secure)
</a><p>	(d) I-type (immediate)
<p></ul><p><p>31.	Jaka jest rola rejestru $ra w MIPS?
<ul><p>	(a) zawiera wskazanie do bloku pamięci liczb rzeczywistych (real adress)
<p>	(b) nie ma go w MIPS, jest tylko w architekturach CISC
<p><a class="correct">	(c) zawiera informację na temat adresu powrotu po wykonaniu instrukcji jal (return adress)
</a><p>	(d) zawiera liczbę losową do wykorzystania w kodzie (random adress)
<p></ul><p><p>32.	Czym jest "endianness"?
<ul><p><a class="correct">	(a) ustawieniem kolejności bajtów w słowie
</a><p>	(b) wybieranym typem zakończenia programu
<p>	(c) rodzajem architektury ISA (typu low-end lub high-end)
<p>	(d) ustawieniem kolejności bitów w bajcie
<p></ul><p><p>33.	W $1 znajduje się liczba 7, a w $2 liczba 42. Po wykonaniu instrukcji add $0, $1, $2 w $0 znajduje się:
<ul><p><a class="correct">	(a) 0
</a><p>	(b) 3
<p>	(c) 49
<p>	(d) $0 się nie zmieni, w $2 znajdzie się 7
<p></ul><p><p>34.	Która taksonomia nie istnieje?
<ul><p>	(a) Flynna
<p>	(b) Fenga
<p>	(c) Handlera
<p><a class="correct">	(d) Stanforda
</a><p></ul><p><p>35.	Czemu stosuje się hierarchię pamięci?
<ul><p>	(a) nie stosuje się
<p>	(b) bo kiedyś się stosowało i tak zostało
<p><a class="correct">	(c) bo jest krótsza droga
</a><p>	(d) dla bezpieczeństwa
<p></ul><p><p>36.	Co charakteryzuje instrukcje R-type?
<ul><p>	(a) działają na pamięci
<p>	(b) działają na wartościach bezpośrednich
<p>	(c) działaja na rejestrze $pc
<p><a class="correct">	(d) działają na rejestrach
</a><p><p><p><p><p><p><p><p><p><p><p></ul><p><p>37.	Co charakteryzuje instrukcje I-type?
<ul><p>	(a) działają na pamięci
<p><a class="correct">	(b) działają na wartościach bezpośrednich
</a><p>	(c) działaja na rejestrze $pc
<p>	(d) działają na rejestrach
<p><p><p><p><p><p><p><p><p><p><p></ul><p><p>38.	Co charakteryzuje instrukcje J-type?
<ul><p>	(a) działają na pamięci
<p>	(b) działają na wartościach bezpośrednich
<p><a class="correct">	(c) działaja na rejestrze $pc
</a><p>	(d) działają na rejestrach
<p><p><p><p><p><p><p><p><p><p><p></ul><p><p>39.	Jeśli wykonamy instrukcję JAL, to gdzie zapisze się adres następnej instrukcji?
<ul><p><a class="correct">	(a) w $ra
</a><p>	(b) w $pc
<p>	(c) nie ma takiej instrukcji
<p>	(d) zapisuje się tylko przy użyciu instrukcji J
<p></ul><p><p>40.	Czym jest branch delay slot w MIPS?
<ul><p><a class="correct">	(a) celowym wykonaniem kolejnej instrukcji po skoku aby minimalnie zaburzyć proces potokowania (pipelining)
</a><p>	(b) wielkością opóźnienia wynikającą z typu wykonywanej instrukcji
<p>	(c) koniecznym do obliczenia rozmiarem gałęzi w przypadku rozwidlenia programu (np. wskutek sprawdzania warunku)
<p>	(d) skokiem do adresu zawartego w $ra w celu poprawnego wyjścia z funkcji do miejsca gdzie była wywołana
<p></ul><p><p>41.	Gdzie trzymany jest stos w MIPS?
<ul><p><a class="correct">	(a) w pamięci
</a><p>	(b) w rejestrach
<p>	(c) w osobnym akumulatorze
<p>	(d) w MIPS nie ma stosu<p></ul><p><p>42.	Kod napisany w assemblerze:
<ul><p>	(a) nie może być osadzany w języku C
<p>	(b) wykonywany jest bezpośrednio w procesorze bez dodatkowej translacji do kodu maszynowego
<p><a class="correct">	(c) na ogół działa szybciej niż napisany w języku wysokiego poziomu
</a><p>	(d) pozwala na osadzenie w nim kodu języka C
<p></ul><p><p>43.	Co oznacza zapis "comment:" w MIPS-ie?
<ul><p>	(a) zapis jest niepoprawny
<p>	(b) komentarz w kodzie
<p><a class="correct">	(c) tworzy label o nazwie "comment", wskazujący na miejsce w pamięci po dwukropku
</a><p></ul><p><p>44.	W jaki sposób można zmienić ASIC do realizowania zupełnie innej operacji?
<ul><p>	(a) używając języka VHDL
<p><a class="correct">	(b) nie jest to możliwe
</a><p>	(c) zmieniając kod asemblera i ponownie go uruchamiając w ASIC
<p>	(d) zmieniając wejścia i wyjścia ASIC
<p></ul><p><p>45.	Jaki układ zajmuje się kontrolą operacji ALU?
<ul><p><a class="correct">	(a) CU — Control Unit
</a><p>	(b) GPU — Graphics Processing Unit
<p>	(c) CPU — Central Processing unit
<p>	(d) ALU jest niezależne i nie potrzebuje kontroli
<p></ul><p><p>46.	W jaki sposób można przenieść dane pomiedzy dwoma głównymi obszarami pamięci w architekturze Harvarda?
<ul><p>	(a) należy użyć szyny danych łączącej dwa obszary pamięci
<p>	(b) architektura robi to samodzielnie w celu zachowania redundancji
<p>	(c) wystarczy użyć odpowiednika instrukcji move dla danej architektury
<p><a class="correct">	(d) nie jest to możliwe
</a><p></ul><p><p>47.	W jaki sposób przechowywane są liczby rzeczywiste wedle standardu IEEE 754 na 32 bitach?
<ul><p>	(a) 1 bit na znak, 15 bitów na część całkowitą, 16 na część dziesiętną
<p>	(b) 1 bit na znak, 5 bitów na lokalizację separatora (kropki), 26 na zakodowanie liczby
<p><a class="correct">	(c) 1 bit na znak, 8 bitów na wykładnik, 23 na mantysę
</a><p>	(d) ten standard nie pozwala na kodowanie liczb rzeczywistych, tylko całkowitych
<p></ul><p><p>48.	Jaka jest rola rejestru $f0 w MIPS?
<ul><p>	(a) przechowuje zero, nie da się zmienić jego wartości
<p><a class="correct">	(b) przechowuje pierwsze 32 bity liczby rzeczywistej double precision lub całą liczbę rzeczywistą single precision
</a><p>	(c) jest flagą ustawiona w przypadku dzielenia przez zero (wskazuje na błąd dzielenia)
<p>	(d) taki rejestr w MIPS nie istnieje, w MIPS wystepuje tylko rejestr $0
<p></ul><p><p>49.	Na co pozwala architektura MISD w taksonomii Flynna?
<ul><p><a class="correct">	(a) wykrywanie błędow, gdyż te same instrukcje mogą być wykonywane na tych samych danych równolegle
</a><p>	(b) na obliczanie zrównoleglone w klastrze
<p>	(c) MISD jako najprostsza architektura wykonuje jedną instrukcję jednoczesnie na tych samych danych
<p>	(d) MISD nie istnieje w taksonomii Flynna
<p></ul><p><p>50.	Czy można uruchomić program napisany w języku wysokiego poziomu (np. C++) stworzony dla architektury CISC na architekturze RISC?
<ul><p>	(a) tak, ale tylko dla wybranych typów procesora CISC i RISC
<p>	(b) nie
<p><a class="correct">	(c) tak, ale wymaga to ponownej kompilacji i odpowiedniej wersji asemblera
</a><p>	(d) tak
<p></ul><p><p>51.	Czym jest architektura bi-endian?
<ul><p>	(a) sposobem ustawienia bajtów w słowie, w tym przypadku od najbardziej znaczących do najmniej znaczących
<p><a class="correct">	(b) ta architektura pozwala pracować zarówno w little-endian jak i big-endian
</a><p>	(c) sposobem ustawienia bajtów w słowie, w tym przypadku od najmniej znaczących do najbardziej znaczących
<p>	(d) korekcją błędów poprzez duplikowanie bitów na początku i na końcu ciągu danych
<p></ul><p><p>52.	Co oznacza instrukcja pop dla MIPS?
<ul><p>	(a) ściąga jedno slowo ze stosu
<p><a class="correct">	(b) MIPS nie wspiera instrukcji pop
</a><p>	(c) odkłada jedno slowo na stos
<p>	(d) oznacza pusty cykl procesora
<p></ul><p><p>53.	Jakiego etapu NIE zawiera potokowanie RISC (pipelining)?
<ul><p>	(a) instruction fetch IF
<p><a class="correct">	(b) instruction cache IC
</a><p>	(c) memory access MEM
<p>	(d) execute EX
<p></ul><p><p>54.	Dlaczego w instrukcjach R-Type wystarczy zakodować rejestr na pięciu bitach?
<ul><p>	(a) ponieważ używamy adresowania względnego
<p>	(b) ponieważ używamy kodowania IEEE 754
<p><a class="correct">	(c) ponieważ wystarczą tylko 32 adresy
</a><p>	(d) rejestr w intrukcjach R-type adresujemy na 32 a nie na pięciu bitach
<p></ul><p><p>55.	Czym jest numeryczny kod maszynowy (numerical machine code)?
<ul><p>	(a) kodem typu instrukcji (opcode)
<p>	(b) zestawem instrukcji asemblera wspieranych przez dany procesor
<p><a class="correct">	(c) skompilowanym kodem asemblera bezpośrednio podawanym do procesora
</a><p>	(d) unikatowym kodem danej architektury procesora (ISA)
<p></ul><p><p>56.	Czym jest akumulator?
<ul><p><a class="correct">	(a) specjalizowanym rejestrem procesora, w którym umieszczane są wyniki operacji jednostki arytmetyczno-logicznej procesora
</a><p>	(b) inną nazwą stosu
<p>	(c) licznikiem służącym do zliczania liczby iteracji pętli
<p>	(d) buforem danych w pamięci RAM o szybkim dostępie (na początku adresacji)
<p></ul><p><p>57.	Co umożliwia sprawne poruszanie sie po stosie MIPS, szczegolnie przy rekurencji?
<ul><p><a class="correct">	(a) frame pointer ($fp)
</a><p>	(b) stack bottom
<p>	(c) stack limit
<p>	(d) instrukcje $pop i $push
<p></ul><p><p>58.	Co cechuje architekturę CISC?
<ul><p><a class="correct">	(a) zmienna długość instrukcji
</a><p>	(b) stała długość instrukcji
<p>	(c) kazda instrukcja wykonuje się dokładnie jeden cykl zegara
<p>	(d) load and store
<p></ul><p><p>59.	Ile wartości można jednocześnie przekazać do rejestru z użyciem instrukcji addi w MIPS?
<ul><p><a class="correct">	(a) jedną
</a><p>	(b) dwie
<p>	(c) trzy
<p>	(d) górne ograniczenie to 32 wartosci
<p></ul><p><p>60.	Jaka jest rola rejestru $sp?
<ul><p>	(a) wskazuje na stack bottom
<p><a class="correct">	(b) wskazuje na początek stosu, poniżej niego (na wyższych adresach pamięci) znajdują się dane stosu
</a><p>	(c) jest to adres powrotu ustawiany przez instrukcję jal
<p>	(d) wskazuje na stack origin
<p></ul><p><p>61.	Co oznacza direct mapping dla pamięci cache?
<ul><p><a class="correct">	(a) dane z danej komórki pamięci mogą znaleźć się tylko w jednym miejscu w cache
</a><p>	(b) dane z danej komórki pamięci mogą znaleźć się w wielu miejscach w pamięci cache
<p>	(c) direct mapping nie dotyczy pamięci cache
<p>	(d) oznacza rozmiar 1:1 pamięci cache i RAM
<p></ul><p><p>62.	Ile komórek pamięci można zaadresować w architekturze 32-bitowej?
<ul><p>	(a) 32 - 1 komórek
<p><a class="correct">	(b) 2^(32) - 1 komórek
</a><p>	(c) nie ma ograniczenia, gdyż można używać adresów względnych
<p>	(d) 32^(32) - 1 komórek<p></ul><p><p>63.	Która architektura była projektowana z myślą aby minimalizować liczbę cykli zegara na instrukcję?
<ul><p>	(a) CISC
<p><a class="correct">	(b) RISC
</a><p>	(c) obie


<img src="image.png" alt="Kod do zadań 64-70">
<p><b>Kod do zadań 64-70</b></p><br>
<p>	(d) żadna z powyższych<p></ul><p><p>64.	Jaka będzie wartość rejestru $11 po zakończeniu wykonania kodu?
<ul><p>	(a) 7
<p><a class="correct">	(b) 8
</a><p>	(c) 6
<p>	(d) 11<p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p></ul><p><p>65.	Która z powyższych instrukcji jest pseudoinstrukcją?
<ul><p>	(a) w linii 1
<p><a class="correct">	(b) w linii 3
</a><p>	(c) w linii 4
<p>	(d) w linii 5<p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p></ul><p><p>66.	O ile bajtów zwiększy się $pc po wykonaniu instrukcji 1?
<ul><p>	(a) o jeden bajt
<p><a class="correct">	(b) o cztery bajty
</a><p>	(c) o dwa słowa
<p>	(d) o 16 bitów<p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p></ul><p><p>67.	Na co będzie wskazywał adres $ra po wykonaniu instrukcji w linii 4?
<ul><p>	(a) na adres pamięci wskazywany przez etykietę here
<p>	(b) zwiększy się o jedno słowo
<p>	(c) zwiększy się o dwa słowa
<p><a class="correct">	(d) nie zmieni się</a><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p></ul><p><p>68.	Ile pamięci będzie zajmował powyższy kod w pamięci?
<ul><p><a class="correct">	(a) sześć słów
</a><p>	(b) 64 bajty
<p>	(c) 256 bajtów
<p>	(d) siedem słów<p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p></ul><p><p>69.	Jaka będzie wartość rejestru $9 po zakończeniu wykonania kodu?
<ul><p>	(a) 7
<p>	(b) 8
<p>	(c) 6
<p><a class="correct">	(d) 1</a><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p></ul><p><p>70.	Ile pamięci będzie zajmował powyższy kod w pamięci?
<ul><p>	(a) sześć bajtów
<p>	(b) 64 bajty
<p>	(c) 256 bajtów
<p><a class="correct">	(d) 24 bajty</a><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p></ul><p><p>71.	W jaki sposób procesor wykonuje instrukcje w pamięci komputera?
<ul><p><a class="correct">	(a) sekwencyjnie komórka po komórce, chyba że natrafi na instrukcje typu J-type
</a><p>	(b) naprzemienne, tzn. czyta najpierw pierwsze osiem słów instrukcji, później osiem słów danych i tak dalej
<p>	(c) w miejscu, tzn. czyta tylko jedną komórkę pamięci, a zadaniem programisty jest zadbać aby umieścić tam odpowiedni kod
<p>	(d) ze wskazaniem, tzn. każda instrukcja zawiera adres kolejnej instrukcji do wykonania<p></ul><p><p>72.	Czym jest hit rate w przypadku pamięci cache?
<ul><p><a class="correct">	(a) stosunkiem liczby żądań do pamięci znalezionych w cache do liczby wszystkich żądań
</a><p>	(b) szybkością dostępu do pamięci cache
<p>	(c) liczbą dostępów do pamięci
<p>	(d) optymalnym rozmiarem pamięci cache w stosunku do pamięci RAM<p></ul><p><p>73.	Gdzie umiejscowiona jest pamięć cache w hierarchii pamięci?
<ul><p>	(a) najwyżej (najszybsza)
<p><a class="correct">	(b) pomiędzy rejestrami a pamięcią RAM (wolniejsza od rejestrów, szybsza niż RAM)
</a><p>	(c) pod pamięcią RAM (wolniejsza niż RAM)
<p>	(d) nie znajduje się w ogóle w hierarchii pamięci, bo jest osobnym typem dla danych<p></ul><p><p>74.	Czym jest przepełnienie stosu?
<ul><p><a class="correct">	(a) umieszczeniem poza stosem instrukcji lub danych nadpisując inne jej fragmenty
</a><p>	(b) zaalokowaniem większej pamięci niż potrzebna na dane
<p>	(c) przepełnieniem bufora rejestrów
<p>	(d) celowym działaniem programisty optymalizującym działanie programu<p></ul><p><p>75.	* Osadzanie kodu:
<ul><p>	(a) można osadzić kod w C w programie napisanym w asemblerze
<p><a class="correct">	(b) można osadzić kod w asemblerze w programie napisanym w C</a><p></ul><p><p>901.	Czy mozna "zlikwidowac" konflikty dostepu do pamieci polegajace na jednoczesnej probie pobrania rozkazu oraz dane?
<ul><p>	(a) Ale przeciez takich konfliktow nie ma
<p>	(b) Brak poprawnej odpowiedzi
<p>	(c) Nie, nie jest to mozliwe
<p><a class="correct">	(d) Tak, wystarczy zastosowac dwie niezalezne pamieci typu "cache"
</a><p></ul><p><p>902.	Czy czynnosci przewidziane w fazie pobrania rozkazu zaleza od typu rozkazu?
<ul><p>	(a) nie, w fazie pobrania rozkazu zawsze wykonywane sa takie same czynnosci, niezaleznie od typu rozkazu
<p>	(b) tak, dla rozkazow adresowych niekiedy zachodzi dodatkowo potrzeba pobrania argumentu
<p><a class="correct">	(c) tak, dla niektorych rozkazów konieczne jest dwukrotne przeprowadzenie deszyfracji
</a><p>	(d) brak poprawnej odpowiedzi
<p></ul><p><p>903.	Kiedy ma miejsce tzw. "migotanie stron"?
<ul><p>	(a) to pojecie pochodzi z kardiologii
<p><a class="correct">	(b) jesli stosowany algorytm wymiany stron usuwa z pamieci ostatnio uzywana strone
</a><p>	(c) brak poprawnej odpowiedzi
<p>	(d) tego nie da sie przewidziec
<p></ul><p><p>904.	Co to jest "wektor przerwań"?
<ul><p>	(a) przykladowo: numer przerwania
<p>	(b) jest to informacja umozliwiajaca identyfikacje przyczyn przerwania
<p>	(c) przykladowo: adres programu obslugi przerwań
<p><a class="correct">	(d) kazda z powyzszych odpowiedzi jest (może byc) poprawna, zależy od typu procesora
</a><p></ul><p><p>905.	Na czym polega metoda zwiekszania szybkosci sumatora nazywana metoda przeniesienia "jedynkowego i zerowego"
<ul><p><a class="correct">	(a) jednoczesnie dla kazdego segmentu sumatora oblicza sie czy na jego wyjsciu pojawi się przeniesienie (zerowe lub jedynkowe)
</a><p>	(b) brak poprawnej odpowiedzi
<p>	(c) wartosci wszystkich przeniesień sa obliczane jednoczesnie
<p>	(d) nie ma takiej metody
<p></ul><p><p>906.	Dlaczego czesciej stosuje sie organizację pamięci typu 3D, a nie 2D?
<ul><p>	(a) czesciej stosuje sie organizację typu 2D poniewaz ma mniejszy uklad adresujacy
<p><a class="correct">	(b) poniewaz organizacja 3D ma "mniejszy" uklad adresujacy
</a><p>	(c) nie ma takich organizacji pamieci
<p>	(d) brak poprawnej odpowiedzi
<p></ul><p><p>907.	Przy adresacji posredniej adres fizyczny jest wyliczany w nastepujacy sposob:
<ul><p><a class="correct">	(a) pod adresem wskazywanym przez adres zawarty w rozkazie znajduje sie adres fizyczny
</a><p>	(b) brak poprawnej odpowiedzi
<p>	(c) adres jest suma adresu zawartego w rozkazie oraz adresu pobranego z tablicy stron
<p>	(d) adres jest suma przesuniecia (nie wystepuje zawsze), bazy oraz adresu zawartego w rozkazie
<p></ul><p><p>908.	Rozwaz nastepujacą instrukcje pętli: realizowane przez 9 pierwszych przebiegow pętli i pętla się kończy (nie ma kolejnego przebiegu). Jaka jest skutecznosc przewidywania skoku, jesli uzywamy dwu-bitowego ukladu przewidywania skoków?
<ul><p>	(a) 80%
<p>	(b) 95%
<p><a class="correct">	(c) 90%
</a><p>	(d) brak poprawnej odpowiedzi
<p></ul><p><p>909.	Po co stosowany jest bufor troj stanowy na styku szyn wewnetrznych i zewnetrznych?
<ul><p>	(a) bufor troj stanowy nie jest stosowany
<p>	(b) umozliwia przesylanie rozkazow do procesora
<p>	(c) umozliwia realizacje przerwania
<p><a class="correct">	(d) brak poprawnej odpowiedzi
</a><p></ul><p><p>910.	Interfejs standardowy to:
<ul><p>	(a) kabel laczący urządzenie zewnetrzne z komputerem
<p><a class="correct">	(b) standard lacznosci w systemie
</a><p>	(c) urzadzenie umozliwiające komunikacje uzytkownika z komputerem
<p>	(d) polaczenie pomiedzy drukarką a komputerem
<p></ul><p><p>911.	Rozwaz ponizszy fragment kodu: LD R3, Dana11; ADD R1, R3; SUB R3, Dana2; ST Wynik, R1; Pomiedzy instrukcjami ADD oraz SUB występuje zależność:
<ul><p>	(a) wlasciwa
<p>	(b) wyjsciowa
<p>	(c) anty zaleznosc
<p><a class="correct">	(d) brak poprawnej odpowiedzi
</a><p></ul><p><p>912.	Zalozmy, ze zrealizowano pamiec wirtualna poprzez podzial pamieci na segmenty. Obliczając adres fizyczny komórki pamięci musimy?
<ul><p><a class="correct">	(a) dodac do siebie adres fizyczny segmentu z tablicy segmentow oraz przemieszczenie w segmencie zawarte w adresie wirtualnym
</a><p>	(b) zestawic adres z adresu fizycznego segmentu pobranego z tablicy segmentow oraz z przemieszczenia w segmencie zawartego w adresie wirtualnym w taki sposób, ze adres segmentu stanowi starsze bity adres a przesuniecie w segmencie mlodsze bity.
<p>	(c) dodac do siebie adres wirtualny oraz zawartosc wyroznionego rejestru
<p>	(d) zadna z odpowiedzi nie jest poprawna
<p></ul><p><p>913.	Kiedy stosujemy ogolne (globalne) maskowanie przerwań?
<ul><p>	(a) kiedy obslugiwane jest przerwanie o wysokim priorytecie
<p><a class="correct">	(b) kiedy ma miejsce przelaczanie programow
</a><p>	(c) nie wolno stosowac ogolnego maskowania
<p>	(d) brak poprawnej odpowiedzi
<p></ul><p><p>914.	Czy stosowany jest podzial segmentow na strony?
<ul><p>	(a) nie stosuje sie takiej organizacji pamieci
<p><a class="correct">	(b) tak, zalezy to od systemu operacyjnego
</a><p>	(c) brak poprawnej odpowiedzi
<p>	(d) tak jest zawsze
<p></ul><p><p>915.	Dlaczego stosowany jest format "upakowany" dla liczb dziesietnych?
<ul><p>	(a) jest to jedyny format dla reprezentacji liczb dziesietnych i jest po prostu wygodny
<p><a class="correct">	(b) format upakowany jest stosowany ze wzgledu na oszczednosc pamięci
</a><p>	(c) format upakowany umozliwia realizacje operacji arytmetycznych na liczbach dziesietnych bez koniecznosci stosowania rozkazow korygujacych otrzymany wyniki (poprawek)
<p>	(d) brak poprawnej odpowiedzi
<p></ul><p><p>916.	Zalozmy, ze zrealizowano pamiec wirtualna poprzez podzial pamieci na strony. Obliczając adres fizyczny dowolnej komórki pamięci musimy?
<ul><p>	(a) Dodac do siebie adres fizyczny strony pobrany z tablicy stron oraz przemieszczenie na stronie zawarte w adresie wirtualnym
<p><a class="correct">	(b) Zestawic adres adresu fizycznego strony pobranego z tablicy stron oraz z przemieszczenia na stronie zawartego w adresie wirtualnym w taki sposob, ze adres strony stanowi starsze bity adresu a przesuniecie na stronie mlodsze bity.
</a><p>	(c) Dodac do siebie adres wirtualny oraz zawartosc wyroznionego rejestru
<p>	(d) sadna z odpowiedzi nie jest poprawna
<p></ul><p><p>917.	Jaki sposob adresacji moze wymagac wielokrotnego dostepu do pamieci?
<ul><p>	(a) Adresacja wzgledna
<p><a class="correct">	(b) Adresacja posrednia
</a><p>	(c) Adresacja bezposrednia
<p>	(d) Inna
<p></ul><p><p>918.	Na czym polega przetwarzanie typu „pipe line" (potokowe)?
<ul><p><a class="correct">	(a) Jedna z mozliwych realizacji polega na nalozeniu na siebie faz wykonania kolejnych rozkazow
</a><p>	(b) W czasie wykonania jednego rozkazu pobierany jest kolejny rozkaz
<p>	(c) Jednoczesnie z pamieci pobieranych jest kilka rozkazow do wykonania
<p>	(d) Niezaleznie przebiega adresacja rozkazu oraz jego wykonanie
<p></ul><p><p>919.	Zalozmy wielopoziomowy system przerwań, kiedy mozliwe jest przejecie oraz obsluga przerwania podczas obsługi innego?
<ul><p>	(a) jesli nowo zglaszane przerwanie ma wyzszy priorytet
<p><a class="correct">	(b) jesli nowo zglaszane przerwanie ma wyzszy priorytet oraz zglaszanie przerwań nie zostało „zamaskowane"
</a><p>	(c) zawsze
<p>	(d) brak poprawnej odpowiedzi
<p></ul><p><p>920.	Czy mozliwa jest sytuacja, ze wszystkie rozkazy w jakims komputerze sa „0-adresowe" (nie mają pola adresowego)?
<ul><p>	(a) Tak, jest to mozliwe w przypadku gdy uzywamy stosu
<p><a class="correct">	(b) Nie, nie jest to mozliwe, musimy miec co najmniej dwa rozkazy adresowe
</a><p>	(c) Nie, nie jest to mozliwe, musimy miec co najmniej trzy rozkazy adresowe
<p>	(d) Nie, nie jest to mozliwe, musimy miec co najmniej jeden rozkaz adresowy
<p></ul><p><p>921.	Po co stosowany jest bufor troj stanowy na styku szyn wewnetrznych i zewnetrznych?
<ul><p>	(a) Bufor troj stanowy nie jest stosowany
<p><a class="correct">	(b) Zastosowanie bufora troj stanowego umozliwia realizacje bezposredniego dostepu do pamięci przez urzadzenia zewnętrzne
</a><p>	(c) Umozliwia przesylanie rozkazow do procesora
<p>	(d) umozliwia realizacje przerwania
<p></ul><p><p>922.	Co to znaczy, ze adres do pamieci jest wyrownany (ang. aligned)?
<ul><p>	(a) Adres jest wyrownany jesli rozmiar slowa wynosi 4 bajty
<p><a class="correct">	(b) Adres jest wyrownany jesli adres slowa (obiektu) A o rozmiarze s bajtów spelnia nastepujacy warunek : A mod s = 0
</a><p>	(c) Brak poprawnej odpowiedzi
<p>	(d) Adres jest wyrownany jesli w sposób niezalezny mamy dostep do róznych bajtów pamieci
<p></ul><p><p>923.	Porownujac architektury wykorzystujące staly rozmiar slowa rozkazowego z architekturami o zmiennym rozmiarze słowa rozkazowego mozna stwierdzic, ze (ang. fixed & variable ebcoding):
<ul><p>	(a) Dla zmiennego rozmiaru slowa rozkazowego programy sa zazwyczaj dluzsze
<p><a class="correct">	(b) Dla stalego rozmiaru slowa rozkazowego programy sa zazwyczaj dłuzsze
</a><p>	(c) Dlugosc programu dla obu opcji jest taki sam
<p>	(d) Brak poprawnej odpowiedzi
<p></ul><p><p>924.	Rozwaz ponizszy fragment kodu: LD R1, Dana24; ADD R1, Dana2; SUB R1, Dana42; ST Wynik, R1. Pomiedzy instrukcjami ADD oraz SUB występuje zależność:
<ul><p>	(a) wlasciwa
<p><a class="correct">	(b) wyjsciowa
</a><p>	(c) anty zaleznosc
<p>	(d) brak poprawnej odpowiedzis
<p></ul><p><p>925.	Przy adresacji wzglednej adres fizyczny jest wyliczany w nastepujacy sposob
<ul><p>	(a) Pod adresem wskazywanym przez adres zawarty w rozkazie znajduje sie adres fizyczny
<p>	(b) Brak poprawnej odpowiedzi //ew by big_mac
<p>	(c) Adres jest suma adresu zawartego w rozkazie oraz adresu pobranego z tablicy stron
<p><a class="correct">	(d) Adres jest suma przesuniecia (nie wystepuje zawsze), bazy oraz adresu zawartego w rozkazie
</a><p></ul><p><p>926.	Czy na podstawie zawartosci pamieci mozna odroznic rozkaz od danej?
<ul><p>	(a) nie da sie odroznic rozkazu od danej, zarówno rozkaz jak i dana sa zapisane jako ciąg zer i jedynek
<p>	(b) Tak, rozkaz od danej musi byc rozrozniany, inaczej komputer nie móglby dzialac
<p>	(c) Tak, dla rozkazow sa zarezerwowane pewne kombinacje zer i jedynek
<p><a class="correct">	(d) brak poprawnej odpowiedzi (Nie da sie odroznic na podstawie zawartosci, ale da sie na podstawie pochodzenia jej adresu)
</a><p></ul><p><p>927.	Konflikt dostepu do danych w przypadku architektur typu RISC polega na:
<ul><p>	(a) kolejna wykonywana instrukcja zada dostepu do rejestru wykorzystywanego przez poprzednią
<p>	(b) Brak poprawnej odpowiedzi
<p>	(c) Kolejna wykonywana instrukcja zada dostepu do zajetego procesora
<p><a class="correct">	(d) Kolejna wykonywana instrukcja zada dostepu do nie wyliczonej jeszcze przez poprzedzającą instrukcje wartosci
</a><p></ul><p><p>928.	Kiedy ma miejsce tzw. „migotanie segmentow"
<ul><p>	(a) To pojecie z kardiologii
<p>	(b) Jesli stosowany algorytm wymiany segmentow usuwa z pamieci ostatnio uzywany segment
<p><a class="correct">	(c) brak poprawnej odpowiedzi
</a><p>	(d) Tego nie da sie przewidziec
<p></ul><p><p>929.	Jesli jednoczesnie procesor oraz urzadzenie zewnetrzne ząda dostepu do pamięci, dostęp dostaje:
<ul><p>	(a) procesor
<p>	(b) urzadzenie zewnetrzne
<p><a class="correct">	(c) nie ma tutaj obowiazującej reguly, raz dostep dostaje procesor raz urządzenie zewnetrzne (odpowiada za to DMAC)
</a><p>	(d) brak poprawnej odpowiedzi
<p></ul><p><p>930.	Czy stosowany jest podzial stron na segmenty?
<ul><p><a class="correct">	(a) nie stosuje sie takiej organizacji pamieci
</a><p>	(b) tak, zalezy to od systemu operacyjnego
<p>	(c) brak poprawnej odpowiedzi
<p>	(d) tak, przeciez to tryb adresowania wirtualnego.
<p></ul><p><p>931.	Ktora z metod rozbudowy pamieci jest praktyczniejsza?
<ul><p>	(a) oczywiscie zwiekszenie liczby slow, poniewaz upraszcza sie adresowanie
<p>	(b) zadna ze znanych metod nie ma "przewagi"
<p><a class="correct">	(c) wydluzanie dlugosci słowa, poniewaz nie powoduje komplikacji układu adresujacego
</a><p>	(d) brak poprawnej odpowiedzi
<p></ul><p>